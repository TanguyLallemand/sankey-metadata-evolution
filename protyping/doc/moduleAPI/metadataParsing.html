<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>module.metadataParsing API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>module.metadataParsing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
#
################################################################################
#
#  CoRGI : The Co-Regulated Gene Investigator
#
#  Copyright: 2019 INRA http://www.inra.fr
#
#  License:
#    CeCILL: http://www.cecill.info/licences/Licence_CeCILL_V2-en.html
#    See the LICENCE file in the project&#39;s top-level directory for details.
#
#  Author:
#    * Tanguy LALLEMAND, BIDEFI team, IRHS
#
################################################################################

import csv
import json

from module.generalParsing import *


def createMetadataNodes(corgiExperiments, catmaMetadataJson, metadataTemplate, sizeOfIterations, condition, metadataJson):
  &#34;&#34;&#34;Allow to create all nodes to visualize evolution of metadata conditions. This algorithm keeps in mind the fact that data are sequential and create nodes for each iterations

  Parameters
  ----------
  corgiExperiments : Dictionnary
      Json with as keys iterations name and in value an array of all experimentation ID involved in iteration
  catmaMetadataJson : Dictionnary
      JSON gathering all informations of each experimentations. As key, ID of experimentation, as value an object of metadata
  metadataTemplate : Dictionnary
      A JSON object gathering all possible nodes. Based on Biological insight tree
  sizeOfIterations : Dictionnary
      Dictionnary with as key iteration number and as value number of experimentations involved in iteration
  condition : int
      A int from loop in main of script, allowing to select whhich condition is parsed in this function
  metadataJson : dictionnary of two arrays, one called nodes, storing all nodes of graph, and links strong all links

  Returns
  -------
  metadataJson : array
      An array containning in first cell a dictionnary of parsed experimentations with iteration number as key and as value an array of parsed metadata of experimentations. Second cell contain gene AT ID in same format as experimentations
  &#34;&#34;&#34;
  listOfId = []
  # Iterating through experiments
  for experimentsIterator in corgiExperiments:
    # Split iteration key to get iteration number
    currentIterationNumber = experimentsIterator.split(&#34;_&#34;)[1]
    # Iterating through all ID of expermimentation for current iteration of CoRGI
    for idOfExperrimentation in corgiExperiments[experimentsIterator]:
      try:
        catmaMetadataJson[idOfExperrimentation][&#34;cond&#34; + str(condition)][0]
      except:
        pass
      else:
        if catmaMetadataJson[idOfExperrimentation][&#34;cond&#34; + str(condition)][0]:
          # Construct a node ID fitting with d3.js script
          constructedId = currentIterationNumber + &#39;#&#39; + \
              str(condition) + &#34;.&#34; + \
              catmaMetadataJson[idOfExperrimentation][&#34;cond&#34; +
                                                      str(condition)][0]
          # Check if node has not already be created because this ID was already computed
          if constructedId not in listOfId:
            # Save it in an array, allowing to keep in memory which nodes have already be computed
            listOfId.append(constructedId)
            # Create a new node, using informations from template
            templateNode = findTemplateNode(constructedId, metadataTemplate)
            # If it is not possible to create a node, create one with all gathered informations
            if templateNode == None:
              templateNode = {&#34;id&#34;: constructedId, &#34;mappedData&#34;: []}
            else:
              templateNode[&#34;id&#34;] = constructedId
              templateNode[&#34;mappedData&#34;] = []
            # Get ID of experimentation stored as a key in catma JSON file
            catmaMetadataJson[idOfExperrimentation][&#34;experimentationID&#34;] = idOfExperrimentation
            # Append in mappedData array all informations of each associated experiments
            templateNode[&#34;mappedData&#34;].append(
                catmaMetadataJson[idOfExperrimentation])
            # Append constructed node in final JSON
            metadataJson[&#34;nodes&#34;].append(templateNode)
          # If node has already been created, just add supplementary mappedData if exist
          else:
            # Store ID of experimentation
            catmaMetadataJson[idOfExperrimentation][&#34;experimentationID&#34;] = idOfExperrimentation
            # Add more experiments for catma JSON
            addExperiments(catmaMetadataJson, metadataJson,
                           idOfExperrimentation, constructedId)
  # Calculate node relative value. (percentage of representation of a particular conditions relatively to all experiments of a given iteration)
  metadataJson = calculateNodesValues(metadataJson, sizeOfIterations)
  return metadataJson


def findTemplateNode(constructedId, metadataTemplate):
  &#34;&#34;&#34;Allow to construct a node object using informations gathered from CoRGI Output and also informations from metadataTemplate

  Parameters
  ----------
  constructedId : string
      A string composed by two part: first a number corresponding on iteration where node appear and in second part ID of condition represented by node. Parts are separated using &#39;#&#39; character
  metadataTemplate : Json Object
      A JSON object gathering all possible nodes. Based on Biological insight tree

  Returns
  -------
  templateNode : Dictionnary
      Dictionnary gathering all informations of a node. Here is an example of a node content:
      {&#34;id&#34;:&#34;3.3.6&#34;, &#34;cond&#34;:&#34;cond3&#34;, &#34;mappedData&#34;:[],&#34;class&#34;:&#34;stress&#34;, &#34;lbl&#34;:&#34;Light (UV...)&#34;, &#34;relativeValue&#34;:41},
  &#34;&#34;&#34;
  # Split contructed ID using &#39;#&#39; character
  nodeSplitted = constructedId.split(&#39;#&#39;)
  # Iterate through nodes of JSON in construction
  for templateNode in metadataTemplate[&#34;nodes&#34;]:
    # Split node ID using &#39;#&#39; character
    templateNodeSplitted = templateNode[&#34;id&#34;].split(&#39;#&#39;)
    # Test if split is ok
    try:
      templateNodeSplitted[1]
    except:
      # IF ID cannot be split, current node is a template node. If he is similar to splitted constructed ID, return template node containning all informations for this condition
      if templateNode[&#34;id&#34;] == nodeSplitted[1]:
        returnedNode = templateNode
        returnedNode[&#34;iteration&#34;] = nodeSplitted[0]
        return returnedNode
    else:
      # Current node is from a particular iteration and not a template node, so mapped DATA is not empty. Still other informations are ok for both nodes. So it can be possible to extract needed informations from this node
      if templateNodeSplitted[1] == nodeSplitted[1]:
        templateNode = {&#34;id&#34;: templateNodeSplitted[1], &#34;cond&#34;: templateNode[&#34;cond&#34;], &#34;mappedData&#34;: [
        ], &#34;class&#34;: templateNode[&#34;class&#34;], &#34;lbl&#34;: templateNode[&#34;lbl&#34;], &#34;iteration&#34;: nodeSplitted[0]}
        return templateNode


def calculateNodesValues(jsonFile, sizeOfIterations):
  &#34;&#34;&#34;Allow to calculate percentage of representation of each experimentation term. To do it, it calculate percentage of genes mapped on current node in relation to the total number of genes

  Parameters
  ----------
  jsonFile : array of dictionnaries
        Array gathering all nodes and links of graph.
  sizeOfIterations : Dictionnary
      Dictionnary with as key iteration number and as value number of experimentations involved in iteration

  Returns
  -------
  jsonFile : array of dictionnaries
        Array gathering all nodes and links of graph with relative value.

  &#34;&#34;&#34;
  for node in jsonFile[&#34;nodes&#34;]:
    # Try to split node ID, if it&#39;s not possible because this ID is from metadata template, function will this node
    nodeSplitted = splitNodesId(node)
    if not nodeSplitted:
      continue
    try:
      node[&#34;cond&#34;]
    except:
      continue
    else:
        # Access to size of current iteration by reconstructing key of this iteration
        sizeOfCurrentIteration = sizeOfIterations[node[&#34;cond&#34;]][&#34;iteration&#34; + &#34;_&#34; + nodeSplitted[0]]
        # Calculate percentage of representation of given node
        # Save it in node information, rounded at 3 decimals
        node[&#34;relativeValue&#34;] = round((len(node[&#34;mappedData&#34;]) / sizeOfCurrentIteration) * 100,3)
  return jsonFile


def addExperiments(catmaMetadataJson, metadataTemplate, idOfExperrimentation, constructedId):
  &#34;&#34;&#34;Allow to add experimentation informations in mappedData array of a given node

  Parameters
  ----------
  constructedId : string
      A string composed by two part: first a number corresponding on iteration where node appear and in second part ID of condition represented by node. Parts are separated using &#39;#&#39; character
  metadataTemplate : Json Object
      A JSON object gathering all possible nodes. Based on Biological insight tree
  catmaMetadataJson : Json Object
      JSON gathering all informations of each experimentations. As key, ID of experimentation, as value an object of metadata
  idOfExperrimentation: string
      A unique ID for experimentation informations. Used as key in catmaMetadataJson
  &#34;&#34;&#34;
  # Iterate through nodes of JSON in construction
  for templateObject in metadataTemplate[&#34;nodes&#34;]:
    # If right experimentation has been found
    if templateObject[&#34;id&#34;] == constructedId:
      # Append it in mappedData array of right node
      templateObject[&#34;mappedData&#34;].append(
          catmaMetadataJson[idOfExperrimentation])

def getSizeOfCategoryPart(corgiExperiments, catmaMetadataJson,sizeOfCategoryPart):
  &#34;&#34;&#34; This function allow to count how many occurences exist in each category for each iterations
  Parameters
  ----------
  corgiExperiments : Dictionnary
      Json with as keys iterations name and in value an array of all experimentation ID involved in iteration
  catmaMetadataJson : Json Object
      JSON gathering all informations of each experimentations. As key, ID of experimentation, as value an object of metadata
  sizeOfCategoryPart : Dictionnary
      A Dictionnary gathering size of each conditions for each iterations. Here is an example of an output
      &#34;sizeOfCategoryPart&#34;: {
        &#34;cond3&#34;: {
          &#34;iteration_0&#34;: 1039,
          &#34;iteration_1&#34;: 35,
          &#34;iteration_3&#34;: 10,
          &#34;iteration_2&#34;: 19
          },
        &#34;cond4&#34;: {
          &#34;iteration_0&#34;: 1040,
          &#34;iteration_1&#34;: 35,
          &#34;iteration_3&#34;: 10,
          &#34;iteration_2&#34;: 19
          },
          &#34;cond1&#34;: {},
          &#34;cond2&#34;: {
            &#34;iteration_0&#34;: 1042,
            &#34;iteration_1&#34;: 35,
            &#34;iteration_3&#34;: 10,
            &#34;iteration_2&#34;: 19
          }
        }
  &#34;&#34;&#34;
  # Iterating through experiments
  for experimentsIterator in corgiExperiments:
    # Iterating through all ID of expermimentation for current iteration of CoRGI
    for idOfExperrimentation in corgiExperiments[experimentsIterator]:
      # Split iteration key to get iteration number
      currentIterationNumber = experimentsIterator.split(&#34;_&#34;)[1]
      # Iterate through metadata keys
      for categoryname in catmaMetadataJson[idOfExperrimentation]:
        #
        if &#34;cond&#34; in categoryname:
          try:
            catmaMetadataJson[idOfExperrimentation][categoryname][0]
          except:
            pass
          else:
            # If conditiobn is not empty
            if catmaMetadataJson[idOfExperrimentation][categoryname][0] != &#39;&#39;:
              # Check if is already initialized
              try:
                sizeOfCategoryPart[categoryname][&#34;iteration&#34; + &#34;_&#34; + currentIterationNumber]
              # If not initialize it and one occurence
              except:
                sizeOfCategoryPart[categoryname][&#34;iteration&#34; + &#34;_&#34; + currentIterationNumber] = 1
              # If it is already initialized, add +1 occurence
              else:
                sizeOfCategoryPart[categoryname][&#34;iteration&#34; + &#34;_&#34; + currentIterationNumber] += 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="module.metadataParsing.addExperiments"><code class="name flex">
<span>def <span class="ident">addExperiments</span></span>(<span>catmaMetadataJson, metadataTemplate, idOfExperrimentation, constructedId)</span>
</code></dt>
<dd>
<section class="desc"><p>Allow to add experimentation informations in mappedData array of a given node</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>constructedId</code></strong> :&ensp;<code>string</code></dt>
<dd>A string composed by two part: first a number corresponding on iteration where node appear and in second part ID of condition represented by node. Parts are separated using '#' character</dd>
<dt><strong><code>metadataTemplate</code></strong> :&ensp;<code>Json</code> <code>Object</code></dt>
<dd>A JSON object gathering all possible nodes. Based on Biological insight tree</dd>
<dt><strong><code>catmaMetadataJson</code></strong> :&ensp;<code>Json</code> <code>Object</code></dt>
<dd>JSON gathering all informations of each experimentations. As key, ID of experimentation, as value an object of metadata</dd>
<dt><strong><code>idOfExperrimentation</code></strong> :&ensp;<code>string</code></dt>
<dd>A unique ID for experimentation informations. Used as key in catmaMetadataJson</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def addExperiments(catmaMetadataJson, metadataTemplate, idOfExperrimentation, constructedId):
  &#34;&#34;&#34;Allow to add experimentation informations in mappedData array of a given node

  Parameters
  ----------
  constructedId : string
      A string composed by two part: first a number corresponding on iteration where node appear and in second part ID of condition represented by node. Parts are separated using &#39;#&#39; character
  metadataTemplate : Json Object
      A JSON object gathering all possible nodes. Based on Biological insight tree
  catmaMetadataJson : Json Object
      JSON gathering all informations of each experimentations. As key, ID of experimentation, as value an object of metadata
  idOfExperrimentation: string
      A unique ID for experimentation informations. Used as key in catmaMetadataJson
  &#34;&#34;&#34;
  # Iterate through nodes of JSON in construction
  for templateObject in metadataTemplate[&#34;nodes&#34;]:
    # If right experimentation has been found
    if templateObject[&#34;id&#34;] == constructedId:
      # Append it in mappedData array of right node
      templateObject[&#34;mappedData&#34;].append(
          catmaMetadataJson[idOfExperrimentation])</code></pre>
</details>
</dd>
<dt id="module.metadataParsing.calculateNodesValues"><code class="name flex">
<span>def <span class="ident">calculateNodesValues</span></span>(<span>jsonFile, sizeOfIterations)</span>
</code></dt>
<dd>
<section class="desc"><p>Allow to calculate percentage of representation of each experimentation term. To do it, it calculate percentage of genes mapped on current node in relation to the total number of genes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>jsonFile</code></strong> :&ensp;<code>array</code> of <code>dictionnaries</code></dt>
<dd>Array gathering all nodes and links of graph.</dd>
<dt><strong><code>sizeOfIterations</code></strong> :&ensp;<code>Dictionnary</code></dt>
<dd>Dictionnary with as key iteration number and as value number of experimentations involved in iteration</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>jsonFile</code></strong> :&ensp;<code>array</code> of <code>dictionnaries</code></dt>
<dd>Array gathering all nodes and links of graph with relative value.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def calculateNodesValues(jsonFile, sizeOfIterations):
  &#34;&#34;&#34;Allow to calculate percentage of representation of each experimentation term. To do it, it calculate percentage of genes mapped on current node in relation to the total number of genes

  Parameters
  ----------
  jsonFile : array of dictionnaries
        Array gathering all nodes and links of graph.
  sizeOfIterations : Dictionnary
      Dictionnary with as key iteration number and as value number of experimentations involved in iteration

  Returns
  -------
  jsonFile : array of dictionnaries
        Array gathering all nodes and links of graph with relative value.

  &#34;&#34;&#34;
  for node in jsonFile[&#34;nodes&#34;]:
    # Try to split node ID, if it&#39;s not possible because this ID is from metadata template, function will this node
    nodeSplitted = splitNodesId(node)
    if not nodeSplitted:
      continue
    try:
      node[&#34;cond&#34;]
    except:
      continue
    else:
        # Access to size of current iteration by reconstructing key of this iteration
        sizeOfCurrentIteration = sizeOfIterations[node[&#34;cond&#34;]][&#34;iteration&#34; + &#34;_&#34; + nodeSplitted[0]]
        # Calculate percentage of representation of given node
        # Save it in node information, rounded at 3 decimals
        node[&#34;relativeValue&#34;] = round((len(node[&#34;mappedData&#34;]) / sizeOfCurrentIteration) * 100,3)
  return jsonFile</code></pre>
</details>
</dd>
<dt id="module.metadataParsing.createMetadataNodes"><code class="name flex">
<span>def <span class="ident">createMetadataNodes</span></span>(<span>corgiExperiments, catmaMetadataJson, metadataTemplate, sizeOfIterations, condition, metadataJson)</span>
</code></dt>
<dd>
<section class="desc"><p>Allow to create all nodes to visualize evolution of metadata conditions. This algorithm keeps in mind the fact that data are sequential and create nodes for each iterations</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>corgiExperiments</code></strong> :&ensp;<code>Dictionnary</code></dt>
<dd>Json with as keys iterations name and in value an array of all experimentation ID involved in iteration</dd>
<dt><strong><code>catmaMetadataJson</code></strong> :&ensp;<code>Dictionnary</code></dt>
<dd>JSON gathering all informations of each experimentations. As key, ID of experimentation, as value an object of metadata</dd>
<dt><strong><code>metadataTemplate</code></strong> :&ensp;<code>Dictionnary</code></dt>
<dd>A JSON object gathering all possible nodes. Based on Biological insight tree</dd>
<dt><strong><code>sizeOfIterations</code></strong> :&ensp;<code>Dictionnary</code></dt>
<dd>Dictionnary with as key iteration number and as value number of experimentations involved in iteration</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>int</code></dt>
<dd>A int from loop in main of script, allowing to select whhich condition is parsed in this function</dd>
<dt><strong><code>metadataJson</code></strong> :&ensp;<code>dictionnary</code> of <code>two</code> <code>arrays</code>, <code>one</code> <code>called</code> <code>nodes</code>, <code>storing</code> <code>all</code> <code>nodes</code> of <code>graph</code>, <code>and</code> <code>links</code> <code>strong</code> <code>all</code> <code>links</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>metadataJson</code></strong> :&ensp;<code>array</code></dt>
<dd>An array containning in first cell a dictionnary of parsed experimentations with iteration number as key and as value an array of parsed metadata of experimentations. Second cell contain gene AT ID in same format as experimentations</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createMetadataNodes(corgiExperiments, catmaMetadataJson, metadataTemplate, sizeOfIterations, condition, metadataJson):
  &#34;&#34;&#34;Allow to create all nodes to visualize evolution of metadata conditions. This algorithm keeps in mind the fact that data are sequential and create nodes for each iterations

  Parameters
  ----------
  corgiExperiments : Dictionnary
      Json with as keys iterations name and in value an array of all experimentation ID involved in iteration
  catmaMetadataJson : Dictionnary
      JSON gathering all informations of each experimentations. As key, ID of experimentation, as value an object of metadata
  metadataTemplate : Dictionnary
      A JSON object gathering all possible nodes. Based on Biological insight tree
  sizeOfIterations : Dictionnary
      Dictionnary with as key iteration number and as value number of experimentations involved in iteration
  condition : int
      A int from loop in main of script, allowing to select whhich condition is parsed in this function
  metadataJson : dictionnary of two arrays, one called nodes, storing all nodes of graph, and links strong all links

  Returns
  -------
  metadataJson : array
      An array containning in first cell a dictionnary of parsed experimentations with iteration number as key and as value an array of parsed metadata of experimentations. Second cell contain gene AT ID in same format as experimentations
  &#34;&#34;&#34;
  listOfId = []
  # Iterating through experiments
  for experimentsIterator in corgiExperiments:
    # Split iteration key to get iteration number
    currentIterationNumber = experimentsIterator.split(&#34;_&#34;)[1]
    # Iterating through all ID of expermimentation for current iteration of CoRGI
    for idOfExperrimentation in corgiExperiments[experimentsIterator]:
      try:
        catmaMetadataJson[idOfExperrimentation][&#34;cond&#34; + str(condition)][0]
      except:
        pass
      else:
        if catmaMetadataJson[idOfExperrimentation][&#34;cond&#34; + str(condition)][0]:
          # Construct a node ID fitting with d3.js script
          constructedId = currentIterationNumber + &#39;#&#39; + \
              str(condition) + &#34;.&#34; + \
              catmaMetadataJson[idOfExperrimentation][&#34;cond&#34; +
                                                      str(condition)][0]
          # Check if node has not already be created because this ID was already computed
          if constructedId not in listOfId:
            # Save it in an array, allowing to keep in memory which nodes have already be computed
            listOfId.append(constructedId)
            # Create a new node, using informations from template
            templateNode = findTemplateNode(constructedId, metadataTemplate)
            # If it is not possible to create a node, create one with all gathered informations
            if templateNode == None:
              templateNode = {&#34;id&#34;: constructedId, &#34;mappedData&#34;: []}
            else:
              templateNode[&#34;id&#34;] = constructedId
              templateNode[&#34;mappedData&#34;] = []
            # Get ID of experimentation stored as a key in catma JSON file
            catmaMetadataJson[idOfExperrimentation][&#34;experimentationID&#34;] = idOfExperrimentation
            # Append in mappedData array all informations of each associated experiments
            templateNode[&#34;mappedData&#34;].append(
                catmaMetadataJson[idOfExperrimentation])
            # Append constructed node in final JSON
            metadataJson[&#34;nodes&#34;].append(templateNode)
          # If node has already been created, just add supplementary mappedData if exist
          else:
            # Store ID of experimentation
            catmaMetadataJson[idOfExperrimentation][&#34;experimentationID&#34;] = idOfExperrimentation
            # Add more experiments for catma JSON
            addExperiments(catmaMetadataJson, metadataJson,
                           idOfExperrimentation, constructedId)
  # Calculate node relative value. (percentage of representation of a particular conditions relatively to all experiments of a given iteration)
  metadataJson = calculateNodesValues(metadataJson, sizeOfIterations)
  return metadataJson</code></pre>
</details>
</dd>
<dt id="module.metadataParsing.findTemplateNode"><code class="name flex">
<span>def <span class="ident">findTemplateNode</span></span>(<span>constructedId, metadataTemplate)</span>
</code></dt>
<dd>
<section class="desc"><p>Allow to construct a node object using informations gathered from CoRGI Output and also informations from metadataTemplate</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>constructedId</code></strong> :&ensp;<code>string</code></dt>
<dd>A string composed by two part: first a number corresponding on iteration where node appear and in second part ID of condition represented by node. Parts are separated using '#' character</dd>
<dt><strong><code>metadataTemplate</code></strong> :&ensp;<code>Json</code> <code>Object</code></dt>
<dd>A JSON object gathering all possible nodes. Based on Biological insight tree</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>templateNode</code></strong> :&ensp;<code>Dictionnary</code></dt>
<dd>Dictionnary gathering all informations of a node. Here is an example of a node content:
{"id":"3.3.6", "cond":"cond3", "mappedData":[],"class":"stress", "lbl":"Light (UV&hellip;)", "relativeValue":41},</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def findTemplateNode(constructedId, metadataTemplate):
  &#34;&#34;&#34;Allow to construct a node object using informations gathered from CoRGI Output and also informations from metadataTemplate

  Parameters
  ----------
  constructedId : string
      A string composed by two part: first a number corresponding on iteration where node appear and in second part ID of condition represented by node. Parts are separated using &#39;#&#39; character
  metadataTemplate : Json Object
      A JSON object gathering all possible nodes. Based on Biological insight tree

  Returns
  -------
  templateNode : Dictionnary
      Dictionnary gathering all informations of a node. Here is an example of a node content:
      {&#34;id&#34;:&#34;3.3.6&#34;, &#34;cond&#34;:&#34;cond3&#34;, &#34;mappedData&#34;:[],&#34;class&#34;:&#34;stress&#34;, &#34;lbl&#34;:&#34;Light (UV...)&#34;, &#34;relativeValue&#34;:41},
  &#34;&#34;&#34;
  # Split contructed ID using &#39;#&#39; character
  nodeSplitted = constructedId.split(&#39;#&#39;)
  # Iterate through nodes of JSON in construction
  for templateNode in metadataTemplate[&#34;nodes&#34;]:
    # Split node ID using &#39;#&#39; character
    templateNodeSplitted = templateNode[&#34;id&#34;].split(&#39;#&#39;)
    # Test if split is ok
    try:
      templateNodeSplitted[1]
    except:
      # IF ID cannot be split, current node is a template node. If he is similar to splitted constructed ID, return template node containning all informations for this condition
      if templateNode[&#34;id&#34;] == nodeSplitted[1]:
        returnedNode = templateNode
        returnedNode[&#34;iteration&#34;] = nodeSplitted[0]
        return returnedNode
    else:
      # Current node is from a particular iteration and not a template node, so mapped DATA is not empty. Still other informations are ok for both nodes. So it can be possible to extract needed informations from this node
      if templateNodeSplitted[1] == nodeSplitted[1]:
        templateNode = {&#34;id&#34;: templateNodeSplitted[1], &#34;cond&#34;: templateNode[&#34;cond&#34;], &#34;mappedData&#34;: [
        ], &#34;class&#34;: templateNode[&#34;class&#34;], &#34;lbl&#34;: templateNode[&#34;lbl&#34;], &#34;iteration&#34;: nodeSplitted[0]}
        return templateNode</code></pre>
</details>
</dd>
<dt id="module.metadataParsing.getSizeOfCategoryPart"><code class="name flex">
<span>def <span class="ident">getSizeOfCategoryPart</span></span>(<span>corgiExperiments, catmaMetadataJson, sizeOfCategoryPart)</span>
</code></dt>
<dd>
<section class="desc"><p>This function allow to count how many occurences exist in each category for each iterations
Parameters</p>
<hr>
<dl>
<dt><strong><code>corgiExperiments</code></strong> :&ensp;<code>Dictionnary</code></dt>
<dd>Json with as keys iterations name and in value an array of all experimentation ID involved in iteration</dd>
<dt><strong><code>catmaMetadataJson</code></strong> :&ensp;<code>Json</code> <code>Object</code></dt>
<dd>JSON gathering all informations of each experimentations. As key, ID of experimentation, as value an object of metadata</dd>
<dt><strong><code>sizeOfCategoryPart</code></strong> :&ensp;<code>Dictionnary</code></dt>
<dd>A Dictionnary gathering size of each conditions for each iterations. Here is an example of an output
"sizeOfCategoryPart": {
"cond3": {
"iteration_0": 1039,
"iteration_1": 35,
"iteration_3": 10,
"iteration_2": 19
},
"cond4": {
"iteration_0": 1040,
"iteration_1": 35,
"iteration_3": 10,
"iteration_2": 19
},
"cond1": {},
"cond2": {
"iteration_0": 1042,
"iteration_1": 35,
"iteration_3": 10,
"iteration_2": 19
}
}</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getSizeOfCategoryPart(corgiExperiments, catmaMetadataJson,sizeOfCategoryPart):
  &#34;&#34;&#34; This function allow to count how many occurences exist in each category for each iterations
  Parameters
  ----------
  corgiExperiments : Dictionnary
      Json with as keys iterations name and in value an array of all experimentation ID involved in iteration
  catmaMetadataJson : Json Object
      JSON gathering all informations of each experimentations. As key, ID of experimentation, as value an object of metadata
  sizeOfCategoryPart : Dictionnary
      A Dictionnary gathering size of each conditions for each iterations. Here is an example of an output
      &#34;sizeOfCategoryPart&#34;: {
        &#34;cond3&#34;: {
          &#34;iteration_0&#34;: 1039,
          &#34;iteration_1&#34;: 35,
          &#34;iteration_3&#34;: 10,
          &#34;iteration_2&#34;: 19
          },
        &#34;cond4&#34;: {
          &#34;iteration_0&#34;: 1040,
          &#34;iteration_1&#34;: 35,
          &#34;iteration_3&#34;: 10,
          &#34;iteration_2&#34;: 19
          },
          &#34;cond1&#34;: {},
          &#34;cond2&#34;: {
            &#34;iteration_0&#34;: 1042,
            &#34;iteration_1&#34;: 35,
            &#34;iteration_3&#34;: 10,
            &#34;iteration_2&#34;: 19
          }
        }
  &#34;&#34;&#34;
  # Iterating through experiments
  for experimentsIterator in corgiExperiments:
    # Iterating through all ID of expermimentation for current iteration of CoRGI
    for idOfExperrimentation in corgiExperiments[experimentsIterator]:
      # Split iteration key to get iteration number
      currentIterationNumber = experimentsIterator.split(&#34;_&#34;)[1]
      # Iterate through metadata keys
      for categoryname in catmaMetadataJson[idOfExperrimentation]:
        #
        if &#34;cond&#34; in categoryname:
          try:
            catmaMetadataJson[idOfExperrimentation][categoryname][0]
          except:
            pass
          else:
            # If conditiobn is not empty
            if catmaMetadataJson[idOfExperrimentation][categoryname][0] != &#39;&#39;:
              # Check if is already initialized
              try:
                sizeOfCategoryPart[categoryname][&#34;iteration&#34; + &#34;_&#34; + currentIterationNumber]
              # If not initialize it and one occurence
              except:
                sizeOfCategoryPart[categoryname][&#34;iteration&#34; + &#34;_&#34; + currentIterationNumber] = 1
              # If it is already initialized, add +1 occurence
              else:
                sizeOfCategoryPart[categoryname][&#34;iteration&#34; + &#34;_&#34; + currentIterationNumber] += 1</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="module" href="index.html">module</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="module.metadataParsing.addExperiments" href="#module.metadataParsing.addExperiments">addExperiments</a></code></li>
<li><code><a title="module.metadataParsing.calculateNodesValues" href="#module.metadataParsing.calculateNodesValues">calculateNodesValues</a></code></li>
<li><code><a title="module.metadataParsing.createMetadataNodes" href="#module.metadataParsing.createMetadataNodes">createMetadataNodes</a></code></li>
<li><code><a title="module.metadataParsing.findTemplateNode" href="#module.metadataParsing.findTemplateNode">findTemplateNode</a></code></li>
<li><code><a title="module.metadataParsing.getSizeOfCategoryPart" href="#module.metadataParsing.getSizeOfCategoryPart">getSizeOfCategoryPart</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>